// Code generated by protoc-gen-go. DO NOT EDIT.
// source: keys.proto

package tao

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

type CryptoVersion int32

const (
	CryptoVersion_CRYPTO_VERSION_1 CryptoVersion = 1
)

var CryptoVersion_name = map[int32]string{
	1: "CRYPTO_VERSION_1",
}
var CryptoVersion_value = map[string]int32{
	"CRYPTO_VERSION_1": 1,
}

func (x CryptoVersion) Enum() *CryptoVersion {
	p := new(CryptoVersion)
	*p = x
	return p
}
func (x CryptoVersion) String() string {
	return proto.EnumName(CryptoVersion_name, int32(x))
}
func (x *CryptoVersion) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(CryptoVersion_value, data, "CryptoVersion")
	if err != nil {
		return err
	}
	*x = CryptoVersion(value)
	return nil
}
func (CryptoVersion) EnumDescriptor() ([]byte, []int) { return fileDescriptor5, []int{0} }

type NamedEllipticCurve int32

const (
	NamedEllipticCurve_PRIME256_V1 NamedEllipticCurve = 1
)

var NamedEllipticCurve_name = map[int32]string{
	1: "PRIME256_V1",
}
var NamedEllipticCurve_value = map[string]int32{
	"PRIME256_V1": 1,
}

func (x NamedEllipticCurve) Enum() *NamedEllipticCurve {
	p := new(NamedEllipticCurve)
	*p = x
	return p
}
func (x NamedEllipticCurve) String() string {
	return proto.EnumName(NamedEllipticCurve_name, int32(x))
}
func (x *NamedEllipticCurve) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(NamedEllipticCurve_value, data, "NamedEllipticCurve")
	if err != nil {
		return err
	}
	*x = NamedEllipticCurve(value)
	return nil
}
func (NamedEllipticCurve) EnumDescriptor() ([]byte, []int) { return fileDescriptor5, []int{1} }

type CryptoCipherMode int32

const (
	CryptoCipherMode_CIPHER_MODE_CTR CryptoCipherMode = 1
)

var CryptoCipherMode_name = map[int32]string{
	1: "CIPHER_MODE_CTR",
}
var CryptoCipherMode_value = map[string]int32{
	"CIPHER_MODE_CTR": 1,
}

func (x CryptoCipherMode) Enum() *CryptoCipherMode {
	p := new(CryptoCipherMode)
	*p = x
	return p
}
func (x CryptoCipherMode) String() string {
	return proto.EnumName(CryptoCipherMode_name, int32(x))
}
func (x *CryptoCipherMode) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(CryptoCipherMode_value, data, "CryptoCipherMode")
	if err != nil {
		return err
	}
	*x = CryptoCipherMode(value)
	return nil
}
func (CryptoCipherMode) EnumDescriptor() ([]byte, []int) { return fileDescriptor5, []int{2} }

type CryptoDerivingMode int32

const (
	CryptoDerivingMode_DERIVING_MODE_HKDF CryptoDerivingMode = 1
)

var CryptoDerivingMode_name = map[int32]string{
	1: "DERIVING_MODE_HKDF",
}
var CryptoDerivingMode_value = map[string]int32{
	"DERIVING_MODE_HKDF": 1,
}

func (x CryptoDerivingMode) Enum() *CryptoDerivingMode {
	p := new(CryptoDerivingMode)
	*p = x
	return p
}
func (x CryptoDerivingMode) String() string {
	return proto.EnumName(CryptoDerivingMode_name, int32(x))
}
func (x *CryptoDerivingMode) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(CryptoDerivingMode_value, data, "CryptoDerivingMode")
	if err != nil {
		return err
	}
	*x = CryptoDerivingMode(value)
	return nil
}
func (CryptoDerivingMode) EnumDescriptor() ([]byte, []int) { return fileDescriptor5, []int{3} }

type CryptoKey_CryptoPurpose int32

const (
	CryptoKey_VERIFYING CryptoKey_CryptoPurpose = 1
	CryptoKey_SIGNING   CryptoKey_CryptoPurpose = 2
	CryptoKey_CRYPTING  CryptoKey_CryptoPurpose = 3
	CryptoKey_DERIVING  CryptoKey_CryptoPurpose = 4
)

var CryptoKey_CryptoPurpose_name = map[int32]string{
	1: "VERIFYING",
	2: "SIGNING",
	3: "CRYPTING",
	4: "DERIVING",
}
var CryptoKey_CryptoPurpose_value = map[string]int32{
	"VERIFYING": 1,
	"SIGNING":   2,
	"CRYPTING":  3,
	"DERIVING":  4,
}

func (x CryptoKey_CryptoPurpose) Enum() *CryptoKey_CryptoPurpose {
	p := new(CryptoKey_CryptoPurpose)
	*p = x
	return p
}
func (x CryptoKey_CryptoPurpose) String() string {
	return proto.EnumName(CryptoKey_CryptoPurpose_name, int32(x))
}
func (x *CryptoKey_CryptoPurpose) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(CryptoKey_CryptoPurpose_value, data, "CryptoKey_CryptoPurpose")
	if err != nil {
		return err
	}
	*x = CryptoKey_CryptoPurpose(value)
	return nil
}
func (CryptoKey_CryptoPurpose) EnumDescriptor() ([]byte, []int) { return fileDescriptor5, []int{0, 0} }

type CryptoKey_CryptoAlgorithm int32

const (
	CryptoKey_ECDSA_SHA        CryptoKey_CryptoAlgorithm = 1
	CryptoKey_AES_CTR_HMAC_SHA CryptoKey_CryptoAlgorithm = 2
	CryptoKey_HMAC_SHA         CryptoKey_CryptoAlgorithm = 3
)

var CryptoKey_CryptoAlgorithm_name = map[int32]string{
	1: "ECDSA_SHA",
	2: "AES_CTR_HMAC_SHA",
	3: "HMAC_SHA",
}
var CryptoKey_CryptoAlgorithm_value = map[string]int32{
	"ECDSA_SHA":        1,
	"AES_CTR_HMAC_SHA": 2,
	"HMAC_SHA":         3,
}

func (x CryptoKey_CryptoAlgorithm) Enum() *CryptoKey_CryptoAlgorithm {
	p := new(CryptoKey_CryptoAlgorithm)
	*p = x
	return p
}
func (x CryptoKey_CryptoAlgorithm) String() string {
	return proto.EnumName(CryptoKey_CryptoAlgorithm_name, int32(x))
}
func (x *CryptoKey_CryptoAlgorithm) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(CryptoKey_CryptoAlgorithm_value, data, "CryptoKey_CryptoAlgorithm")
	if err != nil {
		return err
	}
	*x = CryptoKey_CryptoAlgorithm(value)
	return nil
}
func (CryptoKey_CryptoAlgorithm) EnumDescriptor() ([]byte, []int) { return fileDescriptor5, []int{0, 1} }

type CryptoKey struct {
	Version          *CryptoVersion             `protobuf:"varint,1,req,name=version,enum=tao.CryptoVersion" json:"version,omitempty"`
	Purpose          *CryptoKey_CryptoPurpose   `protobuf:"varint,2,req,name=purpose,enum=tao.CryptoKey_CryptoPurpose" json:"purpose,omitempty"`
	Algorithm        *CryptoKey_CryptoAlgorithm `protobuf:"varint,3,req,name=algorithm,enum=tao.CryptoKey_CryptoAlgorithm" json:"algorithm,omitempty"`
	Key              []byte                     `protobuf:"bytes,4,req,name=key" json:"key,omitempty"`
	XXX_unrecognized []byte                     `json:"-"`
}

func (m *CryptoKey) Reset()                    { *m = CryptoKey{} }
func (m *CryptoKey) String() string            { return proto.CompactTextString(m) }
func (*CryptoKey) ProtoMessage()               {}
func (*CryptoKey) Descriptor() ([]byte, []int) { return fileDescriptor5, []int{0} }

func (m *CryptoKey) GetVersion() CryptoVersion {
	if m != nil && m.Version != nil {
		return *m.Version
	}
	return CryptoVersion_CRYPTO_VERSION_1
}

func (m *CryptoKey) GetPurpose() CryptoKey_CryptoPurpose {
	if m != nil && m.Purpose != nil {
		return *m.Purpose
	}
	return CryptoKey_VERIFYING
}

func (m *CryptoKey) GetAlgorithm() CryptoKey_CryptoAlgorithm {
	if m != nil && m.Algorithm != nil {
		return *m.Algorithm
	}
	return CryptoKey_ECDSA_SHA
}

func (m *CryptoKey) GetKey() []byte {
	if m != nil {
		return m.Key
	}
	return nil
}

type CryptoKeyset struct {
	Keys             []*CryptoKey `protobuf:"bytes,1,rep,name=keys" json:"keys,omitempty"`
	Delegation       *Attestation `protobuf:"bytes,2,opt,name=delegation" json:"delegation,omitempty"`
	XXX_unrecognized []byte       `json:"-"`
}

func (m *CryptoKeyset) Reset()                    { *m = CryptoKeyset{} }
func (m *CryptoKeyset) String() string            { return proto.CompactTextString(m) }
func (*CryptoKeyset) ProtoMessage()               {}
func (*CryptoKeyset) Descriptor() ([]byte, []int) { return fileDescriptor5, []int{1} }

func (m *CryptoKeyset) GetKeys() []*CryptoKey {
	if m != nil {
		return m.Keys
	}
	return nil
}

func (m *CryptoKeyset) GetDelegation() *Attestation {
	if m != nil {
		return m.Delegation
	}
	return nil
}

type PBEData struct {
	Version    *CryptoVersion `protobuf:"varint,1,req,name=version,enum=tao.CryptoVersion" json:"version,omitempty"`
	Cipher     *string        `protobuf:"bytes,2,req,name=cipher" json:"cipher,omitempty"`
	Hmac       *string        `protobuf:"bytes,3,req,name=hmac" json:"hmac,omitempty"`
	Iterations *int32         `protobuf:"varint,4,req,name=iterations" json:"iterations,omitempty"`
	Iv         []byte         `protobuf:"bytes,5,req,name=iv" json:"iv,omitempty"`
	Ciphertext []byte         `protobuf:"bytes,6,req,name=ciphertext" json:"ciphertext,omitempty"`
	// TODO(kwalsh) Should this not use a mac as well for integrity protection?
	Salt             []byte `protobuf:"bytes,7,req,name=salt" json:"salt,omitempty"`
	XXX_unrecognized []byte `json:"-"`
}

func (m *PBEData) Reset()                    { *m = PBEData{} }
func (m *PBEData) String() string            { return proto.CompactTextString(m) }
func (*PBEData) ProtoMessage()               {}
func (*PBEData) Descriptor() ([]byte, []int) { return fileDescriptor5, []int{2} }

func (m *PBEData) GetVersion() CryptoVersion {
	if m != nil && m.Version != nil {
		return *m.Version
	}
	return CryptoVersion_CRYPTO_VERSION_1
}

func (m *PBEData) GetCipher() string {
	if m != nil && m.Cipher != nil {
		return *m.Cipher
	}
	return ""
}

func (m *PBEData) GetHmac() string {
	if m != nil && m.Hmac != nil {
		return *m.Hmac
	}
	return ""
}

func (m *PBEData) GetIterations() int32 {
	if m != nil && m.Iterations != nil {
		return *m.Iterations
	}
	return 0
}

func (m *PBEData) GetIv() []byte {
	if m != nil {
		return m.Iv
	}
	return nil
}

func (m *PBEData) GetCiphertext() []byte {
	if m != nil {
		return m.Ciphertext
	}
	return nil
}

func (m *PBEData) GetSalt() []byte {
	if m != nil {
		return m.Salt
	}
	return nil
}

type ECDSA_SHA_VerifyingKeyV1 struct {
	Curve            *NamedEllipticCurve `protobuf:"varint,1,req,name=curve,enum=tao.NamedEllipticCurve" json:"curve,omitempty"`
	EcPublic         []byte              `protobuf:"bytes,2,req,name=ec_public" json:"ec_public,omitempty"`
	XXX_unrecognized []byte              `json:"-"`
}

func (m *ECDSA_SHA_VerifyingKeyV1) Reset()                    { *m = ECDSA_SHA_VerifyingKeyV1{} }
func (m *ECDSA_SHA_VerifyingKeyV1) String() string            { return proto.CompactTextString(m) }
func (*ECDSA_SHA_VerifyingKeyV1) ProtoMessage()               {}
func (*ECDSA_SHA_VerifyingKeyV1) Descriptor() ([]byte, []int) { return fileDescriptor5, []int{3} }

func (m *ECDSA_SHA_VerifyingKeyV1) GetCurve() NamedEllipticCurve {
	if m != nil && m.Curve != nil {
		return *m.Curve
	}
	return NamedEllipticCurve_PRIME256_V1
}

func (m *ECDSA_SHA_VerifyingKeyV1) GetEcPublic() []byte {
	if m != nil {
		return m.EcPublic
	}
	return nil
}

type ECDSA_SHA_SigningKeyV1 struct {
	Curve            *NamedEllipticCurve `protobuf:"varint,1,req,name=curve,enum=tao.NamedEllipticCurve" json:"curve,omitempty"`
	EcPrivate        []byte              `protobuf:"bytes,2,req,name=ec_private" json:"ec_private,omitempty"`
	EcPublic         []byte              `protobuf:"bytes,3,req,name=ec_public" json:"ec_public,omitempty"`
	XXX_unrecognized []byte              `json:"-"`
}

func (m *ECDSA_SHA_SigningKeyV1) Reset()                    { *m = ECDSA_SHA_SigningKeyV1{} }
func (m *ECDSA_SHA_SigningKeyV1) String() string            { return proto.CompactTextString(m) }
func (*ECDSA_SHA_SigningKeyV1) ProtoMessage()               {}
func (*ECDSA_SHA_SigningKeyV1) Descriptor() ([]byte, []int) { return fileDescriptor5, []int{4} }

func (m *ECDSA_SHA_SigningKeyV1) GetCurve() NamedEllipticCurve {
	if m != nil && m.Curve != nil {
		return *m.Curve
	}
	return NamedEllipticCurve_PRIME256_V1
}

func (m *ECDSA_SHA_SigningKeyV1) GetEcPrivate() []byte {
	if m != nil {
		return m.EcPrivate
	}
	return nil
}

func (m *ECDSA_SHA_SigningKeyV1) GetEcPublic() []byte {
	if m != nil {
		return m.EcPublic
	}
	return nil
}

type AES_CTR_HMAC_SHA_CryptingKeyV1 struct {
	Mode             *CryptoCipherMode `protobuf:"varint,1,req,name=mode,enum=tao.CryptoCipherMode" json:"mode,omitempty"`
	AesPrivate       []byte            `protobuf:"bytes,2,req,name=aes_private" json:"aes_private,omitempty"`
	HmacPrivate      []byte            `protobuf:"bytes,3,req,name=hmac_private" json:"hmac_private,omitempty"`
	XXX_unrecognized []byte            `json:"-"`
}

func (m *AES_CTR_HMAC_SHA_CryptingKeyV1) Reset()                    { *m = AES_CTR_HMAC_SHA_CryptingKeyV1{} }
func (m *AES_CTR_HMAC_SHA_CryptingKeyV1) String() string            { return proto.CompactTextString(m) }
func (*AES_CTR_HMAC_SHA_CryptingKeyV1) ProtoMessage()               {}
func (*AES_CTR_HMAC_SHA_CryptingKeyV1) Descriptor() ([]byte, []int) { return fileDescriptor5, []int{5} }

func (m *AES_CTR_HMAC_SHA_CryptingKeyV1) GetMode() CryptoCipherMode {
	if m != nil && m.Mode != nil {
		return *m.Mode
	}
	return CryptoCipherMode_CIPHER_MODE_CTR
}

func (m *AES_CTR_HMAC_SHA_CryptingKeyV1) GetAesPrivate() []byte {
	if m != nil {
		return m.AesPrivate
	}
	return nil
}

func (m *AES_CTR_HMAC_SHA_CryptingKeyV1) GetHmacPrivate() []byte {
	if m != nil {
		return m.HmacPrivate
	}
	return nil
}

type HMAC_SHA_DerivingKeyV1 struct {
	Mode             *CryptoDerivingMode `protobuf:"varint,1,req,name=mode,enum=tao.CryptoDerivingMode" json:"mode,omitempty"`
	HmacPrivate      []byte              `protobuf:"bytes,2,req,name=hmac_private" json:"hmac_private,omitempty"`
	XXX_unrecognized []byte              `json:"-"`
}

func (m *HMAC_SHA_DerivingKeyV1) Reset()                    { *m = HMAC_SHA_DerivingKeyV1{} }
func (m *HMAC_SHA_DerivingKeyV1) String() string            { return proto.CompactTextString(m) }
func (*HMAC_SHA_DerivingKeyV1) ProtoMessage()               {}
func (*HMAC_SHA_DerivingKeyV1) Descriptor() ([]byte, []int) { return fileDescriptor5, []int{6} }

func (m *HMAC_SHA_DerivingKeyV1) GetMode() CryptoDerivingMode {
	if m != nil && m.Mode != nil {
		return *m.Mode
	}
	return CryptoDerivingMode_DERIVING_MODE_HKDF
}

func (m *HMAC_SHA_DerivingKeyV1) GetHmacPrivate() []byte {
	if m != nil {
		return m.HmacPrivate
	}
	return nil
}

type CryptoHeader struct {
	Version          *CryptoVersion `protobuf:"varint,1,req,name=version,enum=tao.CryptoVersion" json:"version,omitempty"`
	KeyHint          []byte         `protobuf:"bytes,2,req,name=key_hint" json:"key_hint,omitempty"`
	XXX_unrecognized []byte         `json:"-"`
}

func (m *CryptoHeader) Reset()                    { *m = CryptoHeader{} }
func (m *CryptoHeader) String() string            { return proto.CompactTextString(m) }
func (*CryptoHeader) ProtoMessage()               {}
func (*CryptoHeader) Descriptor() ([]byte, []int) { return fileDescriptor5, []int{7} }

func (m *CryptoHeader) GetVersion() CryptoVersion {
	if m != nil && m.Version != nil {
		return *m.Version
	}
	return CryptoVersion_CRYPTO_VERSION_1
}

func (m *CryptoHeader) GetKeyHint() []byte {
	if m != nil {
		return m.KeyHint
	}
	return nil
}

// A PDU to be serialized and signed, including a required context to ensure
// unique deserialization.
type SignaturePDU struct {
	Header *CryptoHeader `protobuf:"bytes,1,req,name=header" json:"header,omitempty"`
	// SECURITY WARNING: Always choose a unique context for each unique type of
	// message. One easy way to do this is to number the messages in a protocol
	// and make the context "ProtocolName Message Y: ProtobufName Version X"
	Context *string `protobuf:"bytes,2,req,name=context" json:"context,omitempty"`
	// The serialized protobuf representing this message.
	Data             []byte `protobuf:"bytes,3,req,name=data" json:"data,omitempty"`
	XXX_unrecognized []byte `json:"-"`
}

func (m *SignaturePDU) Reset()                    { *m = SignaturePDU{} }
func (m *SignaturePDU) String() string            { return proto.CompactTextString(m) }
func (*SignaturePDU) ProtoMessage()               {}
func (*SignaturePDU) Descriptor() ([]byte, []int) { return fileDescriptor5, []int{8} }

func (m *SignaturePDU) GetHeader() *CryptoHeader {
	if m != nil {
		return m.Header
	}
	return nil
}

func (m *SignaturePDU) GetContext() string {
	if m != nil && m.Context != nil {
		return *m.Context
	}
	return ""
}

func (m *SignaturePDU) GetData() []byte {
	if m != nil {
		return m.Data
	}
	return nil
}

// The result of signing.
type SignedData struct {
	Header           *CryptoHeader `protobuf:"bytes,1,req,name=header" json:"header,omitempty"`
	Signature        []byte        `protobuf:"bytes,2,req,name=signature" json:"signature,omitempty"`
	XXX_unrecognized []byte        `json:"-"`
}

func (m *SignedData) Reset()                    { *m = SignedData{} }
func (m *SignedData) String() string            { return proto.CompactTextString(m) }
func (*SignedData) ProtoMessage()               {}
func (*SignedData) Descriptor() ([]byte, []int) { return fileDescriptor5, []int{9} }

func (m *SignedData) GetHeader() *CryptoHeader {
	if m != nil {
		return m.Header
	}
	return nil
}

func (m *SignedData) GetSignature() []byte {
	if m != nil {
		return m.Signature
	}
	return nil
}

// The result of encrypting.
type EncryptedData struct {
	Header           *CryptoHeader `protobuf:"bytes,1,req,name=header" json:"header,omitempty"`
	Iv               []byte        `protobuf:"bytes,2,req,name=iv" json:"iv,omitempty"`
	Ciphertext       []byte        `protobuf:"bytes,3,req,name=ciphertext" json:"ciphertext,omitempty"`
	Mac              []byte        `protobuf:"bytes,4,opt,name=mac" json:"mac,omitempty"`
	XXX_unrecognized []byte        `json:"-"`
}

func (m *EncryptedData) Reset()                    { *m = EncryptedData{} }
func (m *EncryptedData) String() string            { return proto.CompactTextString(m) }
func (*EncryptedData) ProtoMessage()               {}
func (*EncryptedData) Descriptor() ([]byte, []int) { return fileDescriptor5, []int{10} }

func (m *EncryptedData) GetHeader() *CryptoHeader {
	if m != nil {
		return m.Header
	}
	return nil
}

func (m *EncryptedData) GetIv() []byte {
	if m != nil {
		return m.Iv
	}
	return nil
}

func (m *EncryptedData) GetCiphertext() []byte {
	if m != nil {
		return m.Ciphertext
	}
	return nil
}

func (m *EncryptedData) GetMac() []byte {
	if m != nil {
		return m.Mac
	}
	return nil
}

// A PDU to be serialized and fed to HKDF for derivation.
type KeyDerivationPDU struct {
	PreviousHash     []byte  `protobuf:"bytes,1,req,name=previous_hash" json:"previous_hash,omitempty"`
	Size             *uint32 `protobuf:"fixed32,2,req,name=size" json:"size,omitempty"`
	Context          *string `protobuf:"bytes,3,req,name=context" json:"context,omitempty"`
	Index            *uint32 `protobuf:"fixed32,4,req,name=index" json:"index,omitempty"`
	XXX_unrecognized []byte  `json:"-"`
}

func (m *KeyDerivationPDU) Reset()                    { *m = KeyDerivationPDU{} }
func (m *KeyDerivationPDU) String() string            { return proto.CompactTextString(m) }
func (*KeyDerivationPDU) ProtoMessage()               {}
func (*KeyDerivationPDU) Descriptor() ([]byte, []int) { return fileDescriptor5, []int{11} }

func (m *KeyDerivationPDU) GetPreviousHash() []byte {
	if m != nil {
		return m.PreviousHash
	}
	return nil
}

func (m *KeyDerivationPDU) GetSize() uint32 {
	if m != nil && m.Size != nil {
		return *m.Size
	}
	return 0
}

func (m *KeyDerivationPDU) GetContext() string {
	if m != nil && m.Context != nil {
		return *m.Context
	}
	return ""
}

func (m *KeyDerivationPDU) GetIndex() uint32 {
	if m != nil && m.Index != nil {
		return *m.Index
	}
	return 0
}

func init() {
	proto.RegisterType((*CryptoKey)(nil), "tao.CryptoKey")
	proto.RegisterType((*CryptoKeyset)(nil), "tao.CryptoKeyset")
	proto.RegisterType((*PBEData)(nil), "tao.PBEData")
	proto.RegisterType((*ECDSA_SHA_VerifyingKeyV1)(nil), "tao.ECDSA_SHA_VerifyingKey_v1")
	proto.RegisterType((*ECDSA_SHA_SigningKeyV1)(nil), "tao.ECDSA_SHA_SigningKey_v1")
	proto.RegisterType((*AES_CTR_HMAC_SHA_CryptingKeyV1)(nil), "tao.AES_CTR_HMAC_SHA_CryptingKey_v1")
	proto.RegisterType((*HMAC_SHA_DerivingKeyV1)(nil), "tao.HMAC_SHA_DerivingKey_v1")
	proto.RegisterType((*CryptoHeader)(nil), "tao.CryptoHeader")
	proto.RegisterType((*SignaturePDU)(nil), "tao.SignaturePDU")
	proto.RegisterType((*SignedData)(nil), "tao.SignedData")
	proto.RegisterType((*EncryptedData)(nil), "tao.EncryptedData")
	proto.RegisterType((*KeyDerivationPDU)(nil), "tao.KeyDerivationPDU")
	proto.RegisterEnum("tao.CryptoVersion", CryptoVersion_name, CryptoVersion_value)
	proto.RegisterEnum("tao.NamedEllipticCurve", NamedEllipticCurve_name, NamedEllipticCurve_value)
	proto.RegisterEnum("tao.CryptoCipherMode", CryptoCipherMode_name, CryptoCipherMode_value)
	proto.RegisterEnum("tao.CryptoDerivingMode", CryptoDerivingMode_name, CryptoDerivingMode_value)
	proto.RegisterEnum("tao.CryptoKey_CryptoPurpose", CryptoKey_CryptoPurpose_name, CryptoKey_CryptoPurpose_value)
	proto.RegisterEnum("tao.CryptoKey_CryptoAlgorithm", CryptoKey_CryptoAlgorithm_name, CryptoKey_CryptoAlgorithm_value)
}

func init() { proto.RegisterFile("keys.proto", fileDescriptor5) }

var fileDescriptor5 = []byte{
	// 746 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x94, 0x54, 0x5d, 0x6f, 0xe2, 0x46,
	0x14, 0x95, 0x6d, 0x88, 0xd7, 0x17, 0x13, 0xcc, 0x34, 0x5b, 0xdc, 0x6a, 0xd5, 0x52, 0xb6, 0x69,
	0x51, 0xd4, 0x46, 0x0a, 0x52, 0xfb, 0xce, 0xda, 0xde, 0x80, 0x10, 0x04, 0x99, 0x94, 0x2a, 0x4f,
	0xd6, 0xd4, 0x9e, 0xe2, 0x51, 0xc0, 0x76, 0xed, 0x01, 0xc5, 0xfd, 0x11, 0xfd, 0x29, 0xfd, 0x8d,
	0xd5, 0x8c, 0x31, 0x5f, 0xe2, 0x81, 0xbe, 0xf9, 0x8e, 0xcf, 0x9c, 0x73, 0xe7, 0xcc, 0xb9, 0x03,
	0xf0, 0x4a, 0xf2, 0xec, 0x3e, 0x49, 0x63, 0x16, 0x23, 0x85, 0xe1, 0xf8, 0xeb, 0x26, 0x66, 0x8c,
	0x64, 0x0c, 0x33, 0x1a, 0x47, 0xc5, 0x7a, 0xe7, 0x5f, 0x19, 0x34, 0x2b, 0xcd, 0x13, 0x16, 0x8f,
	0x48, 0x8e, 0x3e, 0x82, 0xba, 0x21, 0x69, 0x46, 0xe3, 0xc8, 0x94, 0xda, 0x72, 0xf7, 0xba, 0x87,
	0xee, 0x19, 0x8e, 0xef, 0x0b, 0xc0, 0xbc, 0xf8, 0x83, 0x7e, 0x06, 0x35, 0x59, 0xa7, 0x49, 0x9c,
	0x11, 0x53, 0x16, 0xa0, 0x0f, 0x07, 0xa0, 0x11, 0xc9, 0xb7, 0x5f, 0xd3, 0x02, 0x83, 0x1e, 0x40,
	0xc3, 0xcb, 0x45, 0x9c, 0x52, 0x16, 0xae, 0x4c, 0x45, 0x6c, 0xf8, 0xe6, 0xec, 0x86, 0x7e, 0x89,
	0x42, 0x35, 0x50, 0x5e, 0x49, 0x6e, 0x56, 0xda, 0x72, 0x57, 0xef, 0x3c, 0x42, 0xfd, 0x98, 0xb0,
	0x0e, 0xda, 0xdc, 0x71, 0x87, 0x9f, 0x5f, 0x86, 0x93, 0x47, 0x43, 0x42, 0x35, 0x50, 0x67, 0xc3,
	0xc7, 0x09, 0x2f, 0x64, 0xa4, 0xc3, 0x3b, 0xcb, 0x7d, 0x99, 0x3e, 0xf3, 0x4a, 0xe1, 0x95, 0xed,
	0xb8, 0xc3, 0x39, 0xaf, 0x2a, 0x1d, 0x1b, 0x1a, 0xa7, 0x42, 0x75, 0xd0, 0x1c, 0xcb, 0x9e, 0xf5,
	0xbd, 0xd9, 0xa0, 0x6f, 0x48, 0xe8, 0x06, 0x8c, 0xbe, 0x33, 0xf3, 0xac, 0x67, 0xd7, 0x1b, 0x8c,
	0xfb, 0x96, 0x58, 0x15, 0x9c, 0xbb, 0x4a, 0xe9, 0xb8, 0xa0, 0xef, 0x1a, 0xcf, 0x08, 0x43, 0x1f,
	0xa0, 0xc2, 0x6d, 0x36, 0xa5, 0xb6, 0xd2, 0xad, 0xf5, 0xae, 0x8f, 0x4f, 0x86, 0xbe, 0x07, 0x08,
	0xc8, 0x92, 0x2c, 0x84, 0xe5, 0xa6, 0xdc, 0x96, 0xba, 0xb5, 0x9e, 0x21, 0x30, 0xfd, 0xfd, 0x55,
	0x74, 0xfe, 0x91, 0x40, 0x9d, 0x7e, 0x72, 0x6c, 0xcc, 0xf0, 0x65, 0x57, 0x70, 0x0d, 0x57, 0x3e,
	0x4d, 0x42, 0x92, 0x8a, 0x1b, 0xd0, 0x90, 0x0e, 0x95, 0x70, 0x85, 0x7d, 0x61, 0xaf, 0x86, 0x10,
	0x00, 0x65, 0x24, 0x15, 0xdc, 0x99, 0x70, 0xb1, 0x8a, 0x00, 0x64, 0xba, 0x31, 0xab, 0xdc, 0x51,
	0xfe, 0xbf, 0xd8, 0xcd, 0xc8, 0x1b, 0x33, 0xaf, 0xc4, 0x9a, 0x0e, 0x95, 0x0c, 0x2f, 0x99, 0xa9,
	0x0a, 0xcf, 0xe7, 0xf0, 0xd5, 0xce, 0x17, 0x6f, 0x4e, 0x52, 0xfa, 0x67, 0x4e, 0xa3, 0xc5, 0x88,
	0xe4, 0xde, 0xe6, 0x01, 0xfd, 0x00, 0x55, 0x7f, 0x9d, 0x6e, 0xc8, 0xb6, 0xbf, 0x96, 0xe8, 0x6f,
	0x82, 0x57, 0x24, 0x70, 0x96, 0x4b, 0x9a, 0x30, 0xea, 0x5b, 0xfc, 0x37, 0x6a, 0x82, 0x46, 0x7c,
	0x2f, 0x59, 0xff, 0xb1, 0xa4, 0xbe, 0xe8, 0x53, 0xef, 0x84, 0xd0, 0xda, 0xf3, 0xce, 0xe8, 0x22,
	0xfa, 0xff, 0xac, 0x08, 0x80, 0xb3, 0xa6, 0x74, 0x83, 0x59, 0x11, 0x40, 0xfd, 0x58, 0x49, 0x11,
	0x4a, 0x7f, 0xc1, 0xb7, 0xa7, 0x57, 0xe9, 0x09, 0x0f, 0xf7, 0x8a, 0x1f, 0xa1, 0xb2, 0x8a, 0x83,
	0x52, 0xf0, 0xfd, 0x81, 0xcd, 0x96, 0x70, 0x67, 0x1c, 0x07, 0x04, 0x7d, 0x01, 0x35, 0x4c, 0xb2,
	0x13, 0xbd, 0x1b, 0xd0, 0xb9, 0xdd, 0xbb, 0x55, 0x65, 0x6b, 0x5a, 0x6b, 0x27, 0x65, 0x93, 0x94,
	0x6e, 0xf6, 0x52, 0xb7, 0x47, 0x52, 0xad, 0x03, 0xa9, 0x12, 0x28, 0xc4, 0x4e, 0x79, 0x0b, 0xd3,
	0x9c, 0x32, 0x71, 0x03, 0x82, 0x03, 0x92, 0x5e, 0x96, 0x10, 0x03, 0xde, 0xbd, 0x92, 0xdc, 0x0b,
	0x69, 0xc4, 0xb6, 0x34, 0x53, 0xd0, 0xb9, 0xe3, 0x98, 0xad, 0x53, 0x32, 0xb5, 0x7f, 0x43, 0xdf,
	0xc1, 0x55, 0x28, 0x08, 0x05, 0x4b, 0xad, 0xd7, 0x3c, 0x60, 0xd9, 0x2a, 0x35, 0x40, 0xf5, 0xe3,
	0x48, 0xa4, 0x64, 0x97, 0xb3, 0x00, 0x33, 0xbc, 0x3d, 0xf0, 0x27, 0x00, 0xce, 0x48, 0x02, 0x11,
	0xdc, 0x0b, 0xf8, 0x9a, 0xa0, 0x65, 0x65, 0x0b, 0xdb, 0xae, 0x3c, 0xa8, 0x3b, 0x91, 0xcf, 0x41,
	0x97, 0xd3, 0x14, 0x59, 0x96, 0xcf, 0x64, 0x59, 0xf4, 0xc5, 0x9f, 0x0f, 0x3e, 0x0c, 0x95, 0xb6,
	0xd4, 0xd5, 0x3b, 0xbf, 0x83, 0x31, 0x22, 0xb9, 0xb0, 0x59, 0x0c, 0x04, 0x3f, 0xfa, 0x7b, 0xa8,
	0x27, 0x29, 0xd9, 0xd0, 0x78, 0x9d, 0x79, 0x21, 0xce, 0x42, 0x21, 0x55, 0xcc, 0x00, 0xfd, 0xbb,
	0xe8, 0x4c, 0x3d, 0x3c, 0x7c, 0x31, 0x56, 0x75, 0xa8, 0xd2, 0x28, 0x20, 0x6f, 0x62, 0xa2, 0xd4,
	0xbb, 0xdb, 0xf2, 0x5d, 0x2a, 0x2d, 0xbf, 0x01, 0x43, 0xbc, 0x3d, 0x4f, 0xde, 0xdc, 0x71, 0x67,
	0xc3, 0xa7, 0x89, 0xf7, 0x60, 0x48, 0x77, 0xb7, 0x80, 0xce, 0xa4, 0xb8, 0x01, 0xb5, 0xa9, 0x3b,
	0x1c, 0x3b, 0xbd, 0x5f, 0x7e, 0xf5, 0xe6, 0x1c, 0xf6, 0x23, 0x18, 0x67, 0xb2, 0xd7, 0xb0, 0x86,
	0xd3, 0x81, 0xe3, 0x7a, 0xe3, 0x27, 0xdb, 0xe1, 0x59, 0x36, 0xa4, 0xbb, 0x9f, 0x00, 0x9d, 0x49,
	0xce, 0x97, 0x80, 0xca, 0x97, 0xae, 0x00, 0x0f, 0x46, 0xf6, 0x67, 0x43, 0xfa, 0x2f, 0x00, 0x00,
	0xff, 0xff, 0x78, 0xbe, 0xbf, 0xaa, 0x03, 0x06, 0x00, 0x00,
}
